#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcSpec
# Date:         08.02.2026
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates the frequency spectrum of a given time-domain signal.
Inputs:     1) x:       time-domain signal
Outputs:    1) Y:       frequency-domain spectrum (magnitude)
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
import numpy as np
from scipy.fft import fft


#######################################################################################################################
# Function
#######################################################################################################################
def calcFreq(dictSw, dictAc, dictDc):
    # ==============================================================================
    # Variables
    # ==============================================================================
    freqAc = {}
    freqDc = {}
    freqSw = {}

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Switching
    # ==============================================================================
    for key, value in dictSw.items():
        freqSw[key] = calcSpec(value)

    # ==============================================================================
    # AC-Side
    # ==============================================================================
    for key, value in dictAc.items():
        try:
            freqAc[key] = calcSpec(value)
        except:
            pass

    # ==============================================================================
    # DC-Side
    # ==============================================================================
    for key, value in dictDc.items():
        try:
            freqDc[key] = calcSpec(value)
        except:
            pass

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [freqSw, freqAc, freqDc]


#######################################################################################################################
# Aux Function
#######################################################################################################################
def calcSpec(x):
    # Ensure input is a numpy array (prevents KeyError: 'ALIGNED' with pandas)
    try:
        x = np.asarray(x)
    except:
        raise ValueError("Input cannot be converted to numpy array")
    
    # Check if it is a numeric array
    if not np.issubdtype(x.dtype, np.number):
        raise ValueError("Input is not a numeric array")
    
    # Parameters
    N = int(len(x))
    
    # Calculation
    Y = np.abs(fft(x) / N)[0:int(N / 2)]
    
    # Normalization (Single-sided spectrum)
    if len(Y) > 1:
        Y[1:-2] = 2 * Y[1:-2]
        
    return Y
