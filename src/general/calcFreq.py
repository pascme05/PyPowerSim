#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcFreq
# Date:         28.04.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates the frequency domain results based on the time domain waveforms of the B2 bridge.
Inputs:     1) t:       input time vector (sec)
            2) i_a:     load current (A)
            3) v_a:     load voltage (V)
            4) i_dc:    dc current (A)
            5) v_dc:    dc voltage (V)
Outputs:    1) outAc:   outputs distortion ac side
            2) outDc:   outputs distortion dc side
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
from scipy.fft import fft


#######################################################################################################################
# Function
#######################################################################################################################
def calcFreq(s, xs, timeAc, timeDc):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    # ------------------------------------------
    # General
    # ------------------------------------------
    N = int(len(s))

    # ==============================================================================
    # Variables
    # ==============================================================================
    freqAc = {}
    freqDc = {}
    freqSw = {}

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # AC-Side
    # ==============================================================================
    # ------------------------------------------
    # Switching States
    # ------------------------------------------
    # Sequence
    Y = np.abs(fft(s) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqSw['Sa'] = Y

    # Sampled Reference
    Y = np.abs(fft(xs) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqSw['Xas'] = Y

    # ------------------------------------------
    # Phase
    # ------------------------------------------
    # Current
    Y = np.abs(fft(timeAc['i_a']) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['I_a'] = Y

    # Voltage
    Y = np.abs(fft(timeAc['v_a']) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['V_a'] = Y
    Y = np.abs(fft(timeAc['v_a0']) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['V_a0'] = Y

    # ==============================================================================
    # DC-Side
    # ==============================================================================
    # ------------------------------------------
    # DC-Link
    # ------------------------------------------
    # Current
    Y = np.abs(fft(timeDc['i_dc']) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqDc['I_dc'] = Y

    # Voltage
    Y = np.abs(fft(timeDc['v_dc']) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqDc['V_dc'] = Y

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [freqSw, freqAc, freqDc]
