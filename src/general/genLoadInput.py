#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         template
# Date:         14.08.2023
# Author:       Dr. Pascal A. Schirmer
# Version:      V.0.2
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
import math
import cmath


#######################################################################################################################
# Function
#######################################################################################################################
def genLoadInput(setupExp, setupTopo, setupData):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("------------------------------------------")
    print("START: Generate Load Input")
    print("------------------------------------------")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    # ------------------------------------------
    # Input/Output
    # ------------------------------------------
    Mi = setupData['stat']['Mi']
    Vdc = setupData['stat']['Vdc']
    phiO = math.radians(setupData['stat']['phi'])

    # ------------------------------------------
    # Load
    # ------------------------------------------
    R = setupTopo['R']
    L = setupTopo['L']
    E = setupTopo['E']
    phiE = math.radians(setupTopo['phiE'])

    # ------------------------------------------
    # Operating point
    # ------------------------------------------
    fel = setupTopo['fel']

    # ==============================================================================
    # Topology
    # ==============================================================================
    if setupTopo['sourceType'] == "B2":
        paraV = 2
    elif setupTopo['sourceType'] == "B4":
        paraV = 1
    elif setupTopo['sourceType'] == "B6":
        paraV = 2
    else:
        paraV = 2

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Load Parameters
    # ==============================================================================
    magZ = np.sqrt(R ** 2 + (2 * np.pi * fel * L) ** 2)
    angZ = math.atan2(2 * np.pi * fel * L, R)
    Z = complex(R, 2 * np.pi * fel * L)
    EMF = complex(E * np.cos(phiE), E * np.sin(phiE)) * Mi

    # ==============================================================================
    # Printing Load
    # ==============================================================================
    print(f"INFO: Complex load Z with magnitude {magZ:.2f} (V/A) and angle {math.degrees(angZ):.2f} (deg)")
    print(f"INFO: Back EMF with magnitude {E:.2f} (V/A) and angle {math.degrees(phiE):.2f} (deg)")

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Modulation index is controlled
    # ==============================================================================
    if setupExp['output'] == 'Mi':
        print(f"INFO: Modulation index controlled mode with Mi {setupData['stat']['Mi']:.2f} (p.u.)")

    # ==============================================================================
    # Voltage is controlled
    # ==============================================================================
    elif setupExp['output'] == 'V':
        print(f"INFO: Voltage controlled mode with Vo {setupData['stat']['Vo']:.2f} (V)")
        Mi = setupData['stat']['Vo'] / setupData['stat']['Vdc'] * paraV

    # ==============================================================================
    # Current is controlled
    # ==============================================================================
    elif setupExp['output'] == 'I':
        print(f"INFO: Current controlled mode with Io {setupData['stat']['Io']:.2f} (A)")
        Vo = abs(setupData['stat']['Io'] * Z * np.sqrt(2) + EMF)
        Mi = Vo / setupData['stat']['Vdc'] * paraV

    # ==============================================================================
    # Active power is controlled
    # ==============================================================================
    elif setupExp['output'] == 'P':
        print(f"INFO: Active power controlled mode with Po {setupData['stat']['Po']:.2f} (W)")
        Io = np.sqrt(setupData['stat']['Po'] / R) * np.sqrt(2)
        Io = complex(Io * np.cos(angZ), Io * np.sin(angZ))
        Mi = abs(Io * Z + EMF) / setupData['stat']['Vdc'] * paraV

    # ==============================================================================
    # Reactive power is controlled
    # ==============================================================================
    elif setupExp['output'] == 'Q':
        print(f"INFO: Reactive power controlled mode with Qo {setupData['stat']['Qo']:.2f} (W)")
        Io = np.sqrt(setupData['stat']['Qo'] / (2 * np.pi * fel * L)) * np.sqrt(2)
        Io = complex(Io * np.cos(angZ), Io * np.sin(angZ))
        Mi = abs(Io * Z + EMF) / setupData['stat']['Vdc'] * paraV

    # ==============================================================================
    # Default
    # ==============================================================================
    else:
        print(f"INFO: Modulation index controlled mode with Mi {setupData['stat']['Mi']:.2f} (p.u.)")

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Output Values
    # ==============================================================================
    Vo = Mi * Vdc / paraV
    Io = (complex(Vo, phiO) - EMF) / Z / np.sqrt(2)
    So = Vo * Io / np.sqrt(2)
    Po = So.real
    Qo = So.imag

    # ==============================================================================
    # Printing
    # ==============================================================================
    print(f"INFO: Modulation index being equal to {Mi:.2f} (p.u.)")
    print(f"INFO: Output rms voltage being equal to {Vo:.2f} (V) and {phiO:.2f} (deg)")
    print(
        f"INFO: Output rms current being equal to {cmath.polar(Io)[0]:.2f} (A) and {math.degrees(cmath.polar(Io)[1]):.2f} (deg)")
    print(f"INFO: Output power being equal to {Po:.2f} (W) and {Qo:.2f} (VAr)")

    # ==============================================================================
    # Output
    # ==============================================================================
    setupData['stat']['Vo'] = Vo
    setupData['stat']['Io'] = Io
    setupData['stat']['Po'] = Po
    setupData['stat']['Qo'] = Qo
    setupData['stat']['Mi'] = Mi

    ###################################################################################################################
    # MSG Out
    ###################################################################################################################
    print("------------------------------------------")
    print("END: Generate Load Input")
    print("------------------------------------------")

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return setupData
