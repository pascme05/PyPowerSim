#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcFreq
# Date:         28.04.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates the frequency domain results based on the time domain waveforms.

Input:
1) s:       switching sequence
2) xs:      sampled switching sequence
3) i_a:     phase current (A)
4) v_a:     phase voltage (V)
5) v_a0:    line-neutral voltage (V)
6) i_dc:    dc current (A)
7) v_dc:    dc voltage (V)

Output:
1) outAc:   outputs distortion ac side
2) outDc:   outputs distortion dc side
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================

# ==============================================================================
# External
# ==============================================================================
import numpy as np
from scipy.fft import fft


#######################################################################################################################
# Function
#######################################################################################################################
def calcFreq(s, xs, i_a, v_a, v_a0, i_dc, v_dc):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    # ------------------------------------------
    # General
    # ------------------------------------------
    N = int(len(s))

    # ==============================================================================
    # Variables
    # ==============================================================================
    freqAc = {}
    freqDc = {}
    freqSw = {}

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # AC-Side
    # ==============================================================================
    # ------------------------------------------
    # Switching States
    # ------------------------------------------
    # Sequence
    Y = np.abs(fft(s) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqSw['Sa'] = Y

    # Sampled Reference
    Y = np.abs(fft(xs) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqSw['Xas'] = Y

    # ------------------------------------------
    # Phase
    # ------------------------------------------
    # Current
    Y = np.abs(fft(i_a) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['I_a'] = Y

    # Voltage
    Y = np.abs(fft(v_a) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['V_a'] = Y
    Y = np.abs(fft(v_a0) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqAc['V_a0'] = Y

    # ==============================================================================
    # DC-Side
    # ==============================================================================
    # ------------------------------------------
    # DC-Link
    # ------------------------------------------
    # Current
    Y = np.abs(fft(i_dc) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqDc['I_dc'] = Y

    # Voltage
    Y = np.abs(fft(v_dc) / N)[0:int(N / 2)]
    Y[1:-2] = 2 * Y[1:-2]
    freqDc['V_dc'] = Y

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [freqSw, freqAc, freqDc]
