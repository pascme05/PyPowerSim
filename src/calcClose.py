#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcClose
# Date:         14.05.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates the results for a closed loop solution for any given topology class.
Inputs:     1) top:     topology class
            2) mdl:     all models and transfer functions of the architecture
            3) para:    all parameters used in the simulation
            4) setup:   includes all simulation variables
Outputs:    1) time:    results in the time domain
            2) freq:    results in the frequency domain
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================
from src.general.calcFreq import calcFreq
from src.elec.calcElecSwi import calcElecSwi
from src.elec.calcLossSwi import calcLossSwi
from src.therm.calcTherRC import calcTherRC
from src.elec.calcLossCap import calcLossCap
from src.general.calcAvg import calcAvg
from src.therm.initRC import initRC
from src.elec.calcElecCap import calcElecCap
from src.general.append import app_fel, app_fs

# ==============================================================================
# External
# ==============================================================================
import numpy as np
import math
import pandas as pd
from tqdm import tqdm


#######################################################################################################################
# Function
#######################################################################################################################
def calcTrans(top, mdl, para, setup):
    ###################################################################################################################
    # MSG IN
    ###################################################################################################################
    print("------------------------------------------")
    print("START: Transient solution class", top.name)
    print("------------------------------------------")

    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    fel = setup['Top']['fel']
    fsim = setup['Exp']['fsim']
    fs = setup['Par']['PWM']['fs']
    fc = setup['Par']['Cont']['fc']
    Tel = 1 / fel
    Nsim = int(np.ceil(fsim / fel))
    Npwm = int(np.ceil(fs / fel))
    Ncon = int(np.ceil(fc / fel))
    K = int(setup['Dat']['stat']['cyc'])
    Nel = int(np.ceil(setup['Dat']['trans']['tmax'] * fel))
    Mi = setup['Dat']['stat']['Mi']
    upd = 1

    # ==============================================================================
    # Variables
    # ==============================================================================
    E = setup['Top']['E']
    Vdc = setup['Dat']['stat']['Vdc']
    Iref = setup['Dat']['stat']['Io']
    phiE = math.radians(setup['Top']['phiE'])
    phiV = math.radians(setup['Dat']['stat']['phi'])

    # ==============================================================================
    # Update Frequency
    # ==============================================================================
    iterPWM = Nel * Npwm
    iterCon = Nel * Ncon

    # ==============================================================================
    # Outputs
    # ==============================================================================
    out = top.initData()

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Generate Reference Waveform
    # ==============================================================================
    # ------------------------------------------
    # Time
    # ------------------------------------------
    t_ref = np.linspace(0, K / fel, K * Nsim + 1)

    # ------------------------------------------
    # Reference
    # ------------------------------------------
    [v_ref, e_ref] = top.calcRef(E, phiE, phiV, setup)

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Switching Function
    # ==============================================================================
    [xs, xsh, s, c, x, xN0] = top.calcPWM(v_ref, t_ref, Mi, setup)

    # ==============================================================================
    # Time Domain PWM Waveform (fundamental cycle)
    # ==============================================================================
    [timeAc, timeDc] = top.calcTime(s, e_ref, t_ref, Mi, mdl, Nsim * (K - 1), (K * Nsim + 1), setup)

    # ==============================================================================
    # Controller Init
    # ==============================================================================
    v_ref_i = 1
    M_i = 1

    # ==============================================================================
    # Step Response
    # ==============================================================================
    for i in tqdm(range(iterPWM), desc='Step-Response', position=0):
        # ------------------------------------------
        # Controller
        # ------------------------------------------
        if upd == 1:
            # New Reference
            # TODO: Generate a new reference function based on the controller difference
            v_ref_i = 1
            M_i = 1

        # ------------------------------------------
        # PWM Generation
        # ------------------------------------------
        # New Switching
        [_, _, s_i, _, _, _] = top.calcPWM(v_ref_i, t_ref, M_i, setup)

        # New Back EMF

        # ------------------------------------------
        # Calculate Output
        # ------------------------------------------
        # TODO: Add initial conditions to time series solution of lsim solver
        [tempTimeAc, tempTimeDc] = top.calcTime(s_i, e_ref, t_ref, M_i, mdl, 0, Npwm, setup)

        # ------------------------------------------
        # Append Result
        # ------------------------------------------

        # ------------------------------------------
        # Update Variable
        # ------------------------------------------

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Frequency domain
    # ==============================================================================
    [freqSw, freqAc, freqDc] = calcFreq(s['A'][Nsim:(K * Nsim + 1)], xs['A'][Nsim:(K * Nsim + 1)], timeAc['i_a'], timeAc['v_a'],
                                        timeAc['v_a0'], timeDc['i_dc'], timeDc['v_dc'])

    # ==============================================================================
    # Output
    # ==============================================================================
    [time, freq, _] = top.out(out['elec'], out['loss'], out['ther'], timeAc, timeDc, freqSw, freqAc, freqDc, [], [], t_ref,
                              v_ref, e_ref, s, c, xs, xsh, x, xN0, [], Nsim * (K - 1), (K * Nsim + 1), 1)

    ###################################################################################################################
    # MSG Out
    ###################################################################################################################
    print("------------------------------------------")
    print("END: Transient class", top.name)
    print("------------------------------------------")

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [time, freq]
