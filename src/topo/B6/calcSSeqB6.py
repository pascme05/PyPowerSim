#######################################################################################################################
#######################################################################################################################
# Title:        PWM Distortion Toolkit for Standard Topologies
# Topic:        Power Electronics
# File:         calcSSeqB6
# Date:         01.05.2024
# Author:       Dr. Pascal A. Schirmer
# Version:      V.1.0
# Copyright:    Pascal Schirmer
#######################################################################################################################
#######################################################################################################################

#######################################################################################################################
# Function Description
#######################################################################################################################
"""
This function calculates the switching functions for different modulation techniques including carrier
based PWM, fundamental switching frequency, and optimal pulse patterns.
Inputs:     1) ref:     reference waveform for the PWM
            2) t:       time vector of the PWM (sec)
            3) Mi:      modulation index (p.u.)
            4) setup:   includes all simulation variables
Outputs:    1) xs:      sampled reference waveform
            2) xsh:     sampled reference waveform including zero order hold
            3) c:       carrier signal
            4) s:       switching sequence
"""

#######################################################################################################################
# Import libs
#######################################################################################################################
# ==============================================================================
# Internal
# ==============================================================================
from src.general.helpFnc import deadTime
from src.general.helpFnc import cbInter
from src.general.helpFnc import con2dis
from src.pwm.genSwSeq import genSwSeq
from src.pwm.svPWM import svPWM
from src.pwm.oppPWM import oppPWM

# ==============================================================================
# External
# ==============================================================================
import numpy as np
from scipy import signal


#######################################################################################################################
# Function
#######################################################################################################################
def calcSSeqB6_CB(ref, t, Mi, setup):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Init
    # ==============================================================================
    x0 = {}
    x = {}
    s = {}
    xs = {}
    xsh = {}

    # ==============================================================================
    # Parameters
    # ==============================================================================
    fs = setup['Par']['PWM']['fs']
    Ts = 1 / fs
    fel = setup['Top']['fel']
    id1 = ['A', 'B', 'C']

    # ==============================================================================
    # Variables
    # ==============================================================================
    tmin = int(setup['Par']['PWM']['tmin'] / (t[1] - t[0]))
    td = int(setup['Par']['PWM']['td'] / (t[1] - t[0]))

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Scale reference
    # ==============================================================================
    x0['A'] = Mi * ref['A'] / np.max(ref['A'])
    x0['B'] = Mi * ref['B'] / np.max(ref['B'])
    x0['C'] = Mi * ref['C'] / np.max(ref['C'])
    xN0 = np.zeros(np.size(x0['A']))
    xAll = np.vstack((x0['A'], x0['B'], x0['C'])).transpose()

    # ==============================================================================
    # Clark Transform
    # ==============================================================================
    phi = np.arcsin(ref['A'][0] / np.max(ref['A']))

    # ==============================================================================
    # Zero-Sequence
    # ==============================================================================
    # ------------------------------------------
    # SPWM
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "SPWM":
        xN0 = np.zeros(np.size(x0['A']))

    # ------------------------------------------
    # SVPWM
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "SVPWM":
        xN0 = 1 / 4 * Mi * signal.sawtooth(3 * 2 * np.pi * fel * (t - (0.25 - phi / (2 * np.pi)) / fel), 0.5)

    # ------------------------------------------
    # THIPWM1/4
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "THIPWM4":
        xN0 = 1 / 4 * Mi * np.sin(3 * 2 * np.pi * fel * (t + (phi / (2 * np.pi)) / fel))

    # ------------------------------------------
    # THIPWM1/6
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "THIPWM6":
        xN0 = 1 / 4 * Mi * np.sin(3 * 2 * np.pi * fel * (t + (phi / (2 * np.pi)) / fel))

    # ------------------------------------------
    # DPWM0
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWM0":
        xAll_s = np.roll(xAll, shift=-int(len(xN0) / 12), axis=0)
        id2 = np.argsort(abs(xAll_s), axis=1)
        for i in range(0, len(xN0)):
            xN0[i] = np.sign(xAll[i, id2[i, 2]]) - xAll[i, id2[i, 2]]

    # ------------------------------------------
    # DPWM1
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWM1":
        xAll_s = np.roll(xAll, shift=0, axis=0)
        id2 = np.argsort(abs(xAll_s), axis=1)
        for i in range(0, len(xN0)):
            xN0[i] = np.sign(xAll[i, id2[i, 2]]) - xAll[i, id2[i, 2]]

    # ------------------------------------------
    # DPWM2
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWM2":
        xAll_s = np.roll(xAll, shift=int(len(xN0) / 12), axis=0)
        id2 = np.argsort(abs(xAll_s), axis=1)
        for i in range(0, len(xN0)):
            xN0[i] = np.sign(xAll[i, id2[i, 2]]) - xAll[i, id2[i, 2]]

    # ------------------------------------------
    # DPWM3
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWM3":
        id2 = np.argsort(abs(xAll), axis=1)
        for i in range(0, len(xN0)):
            xN0[i] = np.sign(xAll[i, id2[i, 1]]) - xAll[i, id2[i, 1]]

    # ------------------------------------------
    # DPWMMIN
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWMMIN":
        xN0 = -1 - np.min(xAll, axis=1)

    # ------------------------------------------
    # DPWMMAX
    # ------------------------------------------
    if setup['Par']['PWM']['zero'] == "DPWMMAX":
        xN0 = 1 - np.max(xAll, axis=1)

    # ==============================================================================
    # Line-to-Line References
    # ==============================================================================
    x['A'] = x0['A'] + xN0
    x['B'] = x0['B'] + xN0
    x['C'] = x0['C'] + xN0

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Carrier
    # ==============================================================================
    if setup['Par']['PWM']['tri'] == "RE":
        c = signal.sawtooth(2 * np.pi * fs * t, 1) * (-1)
    elif setup['Par']['PWM']['tri'] == "FE":
        c = signal.sawtooth(2 * np.pi * fs * (t - 0.5 / fs), 0) * (-1)
    elif setup['Par']['PWM']['tri'] == "AM":
        c = signal.sawtooth(2 * np.pi * fs * t, 1 / 3) * (-1)
    else:
        c = signal.sawtooth(2 * np.pi * fs * (t - 0.5 / fs), 0.5)
    c = (2 * (c - min(c)) / (max(c) - min(c))) - 1

    # ==============================================================================
    # Sampling
    # ==============================================================================
    for i in range(0, len(id1)):
        if setup['Par']['PWM']['samp'] == "RS":
            if setup['Par']['PWM']['upd'] == "SE":
                xs[id1[i]] = con2dis(x[id1[i]], t, Ts)
                xsh[id1[i]] = np.roll(x[id1[i]], int(len(xs[id1[i]]) * fel / fs))
            else:
                xs[id1[i]] = con2dis(x[id1[i]], t, Ts / 2)
                xsh[id1[i]] = np.roll(x[id1[i]], int(len(xs[id1[i]]) * fel / fs / 2))
        else:
            xs[id1[i]] = x[id1[i]]
            xsh[id1[i]] = x[id1[i]]

    # ==============================================================================
    # Intersections
    # ==============================================================================
    for i in range(0, len(id1)):
        s[id1[i]] = cbInter(xs[id1[i]], c, Mi, tmin)

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Minimum Pulse Width
    # ==============================================================================
    if setup['Par']['PWM']['tmin'] > 0:
        for i in range(0, len(id1)):
            hold = tmin
            for ii in range(0, len(s)):
                if hold >= tmin:
                    if Mi != 0:
                        s[id1[i]][ii] = s[id1[i]][ii]
                    hold = 0
                else:
                    s[id1[i]][i] = s[id1[i]][ii - 1]
                    hold = hold + 1

    # ==============================================================================
    # Dead-time
    # ==============================================================================
    if setup['Par']['PWM']['td'] > 0:
        for i in range(0, len(id1)):
            s[id1[i]] = deadTime(s[id1[i]], td)

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [xs, xsh, s, c, x, xN0]


#######################################################################################################################
# Function
#######################################################################################################################
def calcSSeqB6_FF(ref, t, Mi, setup):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Parameters
    # ==============================================================================
    fel = setup['Top']['fel']
    id1 = ['A', 'B', 'C']

    # ==============================================================================
    # Variables
    # ==============================================================================
    x0 = {}
    s = {}
    x = {}

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Scale reference
    # ==============================================================================
    x0['A'] = Mi * ref['A'] / np.max(ref['A'])
    x0['B'] = Mi * ref['B'] / np.max(ref['B'])
    x0['C'] = Mi * ref['C'] / np.max(ref['C'])

    # ==============================================================================
    # Carrier
    # ==============================================================================
    c = np.zeros(np.size(t))

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    for i in range(0, len(id1)):
        s[id1[i]] = signal.square(2 * np.pi * fel * t - i * (np.pi * 2) / 3, duty=Mi / 2)

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Neutral Voltage
    # ==============================================================================
    xN0 = 1 / 3 * (s['A'] + s['B'] + s['C'])

    # ==============================================================================
    # Line-to-Line References
    # ==============================================================================
    x['A'] = x0['A'] + xN0
    x['B'] = x0['B'] + xN0
    x['C'] = x0['C'] + xN0

    # ==============================================================================
    # Output
    # ==============================================================================
    xs = x
    xsh = x

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [xs, xsh, s, c, x, xN0]


#######################################################################################################################
# Function
#######################################################################################################################
def calcSSeqB6_SV(ref, t, Mi, setup):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Init
    # ==============================================================================
    x0 = {}
    s = {}
    x = {}
    xs = {}
    xsh = {}
    mS = {}

    # ==============================================================================
    # Parameters
    # ==============================================================================
    # ------------------------------------------
    # General
    # ------------------------------------------
    fs = setup['Par']['PWM']['fs']
    fel = setup['Top']['fel']
    Tel = 1 / fel
    id1 = ['A', 'B', 'C']

    # ------------------------------------------
    # PWM
    # ------------------------------------------
    q = int(fs / fel)
    N = int((t[-1] - t[0]) / Tel)
    K = int(len(t) / (q * N))
    if setup['Par']['PWM']['upd'] == "SE":
        Ns = q
        Terr = -K / 2
    else:
        Ns = 2 * q
        Terr = -K / 4
    tmin = int(setup['Par']['PWM']['tmin'] / (t[1] - t[0]))
    td = int(setup['Par']['PWM']['td'] / (t[1] - t[0]))

    # ==============================================================================
    # Variables
    # ==============================================================================
    ts = np.linspace(0, 2, K)
    ss = np.zeros(np.size(t))
    xN0 = np.zeros(np.size(t))
    rr = np.zeros((Ns * N, 1))
    t1 = np.zeros((Ns * N, 1))
    t2 = np.zeros((Ns * N, 1))
    t0 = np.zeros((Ns * N, 1))
    t7 = np.zeros((Ns * N, 1))
    s['A'] = np.zeros(np.size(t))
    s['B'] = np.zeros(np.size(t))
    s['C'] = np.zeros(np.size(t))
    xs['A'] = np.zeros(np.size(t))
    xs['B'] = np.zeros(np.size(t))
    xs['C'] = np.zeros(np.size(t))

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Scale reference
    # ==============================================================================
    x0['A'] = Mi * ref['A'] / np.max(ref['A'])
    x0['B'] = Mi * ref['B'] / np.max(ref['B'])
    x0['C'] = Mi * ref['C'] / np.max(ref['C'])

    # ==============================================================================
    # Clark Transform
    # ==============================================================================
    ref['alpha'] = 2/3 * (ref['A'] - 0.5 * ref['B'] - 0.5 * ref['C'])
    ref['beta'] = 2/3 * (np.sqrt(3) / 2 * ref['B'] - np.sqrt(3) / 2 * ref['C'])
    phi = np.arctan2(ref['beta'], ref['alpha'])

    # ==============================================================================
    # Mapping Functions
    # ==============================================================================
    mS['A'] = [-1, 1, 1, -1, -1, -1, 1, 1]
    mS['B'] = [-1, -1, 1, 1, 1, -1, -1, 1]
    mS['C'] = [-1, -1, -1, -1, 1, 1, 1, 1]

    # ==============================================================================
    # Define Switching Sequence
    # ==============================================================================
    [seq, k] = genSwSeq(setup)

    # ==============================================================================
    # Zero-Sequence
    # ==============================================================================
    for i in range(0, len(t)):
        alpha = i * N / len(t) * 2 * np.pi + phi[0] + 2 * np.pi
        alpha = alpha + Terr / len(t) * N * (2 * np.pi)
        [d0, d1, d2, d7, _] = svPWM(k, alpha, Mi)
        xN0[i] = (-d0 - d1 / 3 + d2 / 3 + d7)

    # ==============================================================================
    # Line-to-Line References
    # ==============================================================================
    x['A'] = x0['A'] + xN0
    x['B'] = x0['B'] + xN0
    x['C'] = x0['C'] + xN0

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Determine Sector
    # ==============================================================================
    for i in range(0, Ns * N):
        alpha = i / Ns * 2 * np.pi + phi[0] + 2 * np.pi
        alpha = alpha + Terr / len(t) * N * (2 * np.pi)
        [t0[i], t1[i], t2[i], t7[i], rr[i]] = svPWM(k, alpha, Mi)

    # ==============================================================================
    # Switching times
    # ==============================================================================
    if setup['Par']['PWM']['upd'] == "SE":
        st = np.hstack((t0, t0 + t1, 1 - t7, np.ones((Ns * N, 1)), 1 + t7, 1 + t7 + t2, 2 - t0, 2 * np.ones((Ns * N, 1))))
    else:
        st1 = np.hstack((t0, t0 + t1, 1 - t7, np.ones((Ns * N, 1))))
        st2 = np.roll(np.hstack((1 + t7, 1 + t7 + t2, 2 - t0, 2 * np.ones((Ns * N, 1)))), -1, axis=0)
        st = np.hstack((st1, st2))
        st = st[::2]
        rr = rr[::2]

    # ==============================================================================
    # Switching states
    # ==============================================================================
    for i in range(0, q * N):
        j = 0
        for ii in range(0, K):
            if st[i, j] > ts[ii]:
                ss[ii + K * i] = seq[int(rr[i] - 1)][j]
            else:
                j = j + 1
                ss[ii + K * i] = ss[ii + K * i - 1]

    # ==============================================================================
    # Sampled waveform
    # ==============================================================================
    for i in range(0, len(id1)):
        for ii in range(0, len(x[id1[i]])):
            if (ii % int(len(t) / (Ns * N))) == 0:
                xs[id1[i]][ii] = x[id1[i]][ii]
            else:
                xs[id1[i]][ii] = xs[id1[i]][ii - 1]

    # ==============================================================================
    # Shifted waveform
    # ==============================================================================    
    for i in range(0, len(id1)):
        if setup['Par']['PWM']['upd'] == "SE":
            xsh[id1[i]] = np.roll(x0[id1[i]], int(len(xs[id1[i]]) * fel / fs))
        else:
            xsh[id1[i]] = np.roll(x0[id1[i]], int(len(xs[id1[i]]) * fel / fs / 2))

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Minimum Pulse Width
    # ==============================================================================
    if setup['Par']['PWM']['tmin'] > 0:
        for i in range(0, len(id1)):
            hold = tmin
            for ii in range(0, len(ss)):
                if hold >= tmin:
                    if Mi != 0:
                        s[id1[i]][ii] = mS[id1[i]][int(ss[ii])]
                    hold = 0
                else:
                    s[id1[i]][i] = s[id1[i]][ii - 1]
                    hold = hold + 1
    else:
        for i in range(0, len(id1)):
            for ii in range(0, len(ss)):
                if Mi != 0:
                    s[id1[i]][ii] = mS[id1[i]][int(ss[ii])]

    # ==============================================================================
    # Dead-time
    # ==============================================================================
    if setup['Par']['PWM']['td'] > 0:
        for i in range(0, len(id1)):
            s[id1[i]] = deadTime(s[id1[i]], td)

    # ==============================================================================
    # Outputs
    # ==============================================================================
    c = ss

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [xs, xsh, s, c, x, xN0]


#######################################################################################################################
# Function
#######################################################################################################################
def calcSSeqB6_OPP(ref, t, Mi, setup):
    ###################################################################################################################
    # Initialisation
    ###################################################################################################################
    # ==============================================================================
    # Init
    # ==============================================================================
    x0 = {}
    s = {}
    x = {}
    xs = {}
    xsh = {}

    # ==============================================================================
    # Parameters
    # ==============================================================================
    # ------------------------------------------
    # General
    # ------------------------------------------
    fs = setup['Par']['PWM']['fs']
    fel = setup['Top']['fel']
    Tel = 1 / fel
    id1 = ['A', 'B', 'C']

    # ------------------------------------------
    # PWM
    # ------------------------------------------
    q = int(fs / fel)
    kmax = 10 * q
    N = int((t[-1] - t[0]) / Tel)
    if setup['Par']['PWM']['upd'] == "SE":
        Ns = q
    else:
        Ns = 2 * q
    tmin = int(setup['Par']['PWM']['tmin'] / (t[1] - t[0]))
    td = int(setup['Par']['PWM']['td'] / (t[1] - t[0]))

    # ==============================================================================
    # Variables
    # ==============================================================================
    ang = np.linspace(0, np.pi*2*N, np.size(t))
    ss = (-1) * np.ones(np.size(t))
    xN0 = np.zeros(np.size(t))
    c = np.zeros(np.size(t))
    ang_total = []
    val_total = []
    s['A'] = np.zeros(np.size(t))
    s['B'] = np.zeros(np.size(t))
    s['C'] = np.zeros(np.size(t))
    xs['A'] = np.zeros(np.size(t))
    xs['B'] = np.zeros(np.size(t))
    xs['C'] = np.zeros(np.size(t))

    ###################################################################################################################
    # Pre-Processing
    ###################################################################################################################
    # ==============================================================================
    # Scale reference
    # ==============================================================================
    x0['A'] = Mi * ref['A'] / np.max(ref['A'])
    x0['B'] = Mi * ref['B'] / np.max(ref['B'])
    x0['C'] = Mi * ref['C'] / np.max(ref['C'])

    # ==============================================================================
    # Line-to-Line References
    # ==============================================================================
    x['A'] = x0['A'] + xN0
    x['B'] = x0['B'] + xN0
    x['C'] = x0['C'] + xN0

    ###################################################################################################################
    # Calculation
    ###################################################################################################################
    # ==============================================================================
    # Fundamental Angles (0, 2pi)
    # ==============================================================================
    [ang_fun, val_fun, _] = oppPWM(kmax, q, Mi/4*np.pi, 4, setup)

    # ==============================================================================
    # Complete Angles
    # ==============================================================================
    for i in range(0, N):
        if i == 0:
            ang_total = ang_fun
            val_total = val_fun
        else:
            ang_total = np.concatenate((ang_total, ang_fun+2*np.pi*i), axis=0)
            val_total = np.concatenate((val_total, val_fun), axis=0)

    # ==============================================================================
    # Switching times
    # ==============================================================================
    # ------------------------------------------
    # Switching Edges
    # ------------------------------------------
    for i in range(0, len(ang_total)):
        idx = np.argmin(abs(ang - ang_total[i]))
        c[idx] = (-1) ** i

    # ------------------------------------------
    # Switching Function
    # ------------------------------------------
    for i in range(1, len(ss)):
        if c[i] == 0:
            ss[i] = ss[i - 1]
        else:
            ss[i] = c[i]

    # ------------------------------------------
    # Direction
    # ------------------------------------------
    for i in range(1, len(ss)):
        if ref['A'][i] >= 0:
            ss[i] = ss[i] * (+1)
        else:
            ss[i] = ss[i] * (-1)
    ss = -ss

    # ==============================================================================
    # Three Phases
    # ==============================================================================
    for i in range(0, len(id1)):
        s[id1[i]] = np.roll(ss, int(np.floor(i * 120 / 360 / N * len(ss))))

    # ==============================================================================
    # Sampled waveform
    # ==============================================================================
    for i in range(0, len(id1)):
        for ii in range(0, len(x[id1[i]])):
            if (ii % int(len(t) / (Ns * N))) == 0:
                xs[id1[i]][ii] = x[id1[i]][ii]
            else:
                xs[id1[i]][ii] = xs[id1[i]][ii - 1]

    # ==============================================================================
    # Shifted waveform
    # ==============================================================================
    for i in range(0, len(id1)):
        if setup['Par']['PWM']['upd'] == "SE":
            xsh[id1[i]] = np.roll(x0[id1[i]], int(len(xs[id1[i]]) * fel / fs))
        else:
            xsh[id1[i]] = np.roll(x0[id1[i]], int(len(xs[id1[i]]) * fel / fs / 2))

    ###################################################################################################################
    # Post-Processing
    ###################################################################################################################
    # ==============================================================================
    # Switching Function
    # ==============================================================================
    if setup['Par']['PWM']['tmin'] > 0:
        for i in range(0, len(ss)):
            hold = tmin
            for ii in range(0, len(id1)):
                if hold >= tmin:
                    if Mi != 0:
                        s[id1[ii]][i] = s[id1[ii]][i]
                    hold = 0
                else:
                    s[id1[ii]][i] = s[id1[ii]][i - 1]
                    hold = hold + 1

    # ==============================================================================
    # Dead-time
    # ==============================================================================
    if setup['Par']['PWM']['td'] > 0:
        for i in range(0, len(id1)):
            s[id1[i]] = deadTime(s[id1[i]], td)

    ###################################################################################################################
    # Return
    ###################################################################################################################
    return [xs, xsh, s, c, x, xN0]
